{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useWeb3React } from '@web3-react/core';\nimport { useCallback, useEffect, useState } from 'react';\nimport { injected } from './connectors';\nexport function useEagerConnect() {\n  _s();\n\n  const {\n    activate,\n    active\n  } = useWeb3React();\n  const [tried, setTried] = useState(false); // use useCallback() and useEffect() hooks together so that tryActivate() will only\n  // be called once when attempting eager connection\n\n  const tryActivate = useCallback(() => {\n    async function _tryActivate() {\n      const isAuthorized = await injected.isAuthorized();\n\n      if (isAuthorized) {\n        try {\n          await activate(injected, undefined, true);\n        } catch (error) {\n          window.alert('Error!' + (error && error.message ? `\\n\\n${error.message}` : ''));\n        }\n      }\n\n      setTried(true);\n    }\n\n    _tryActivate();\n  }, [activate]);\n  useEffect(() => {\n    tryActivate();\n  }, [tryActivate]); // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(() => {\n    if (!tried && active) {\n      setTried(true);\n    }\n  }, [tried, active]);\n  return tried;\n}\n\n_s(useEagerConnect, \"IfuoVjyQS36/jBH3fIP5tBtAVhA=\", false, function () {\n  return [useWeb3React];\n});\n\nexport function useInactiveListener() {\n  _s2();\n\n  let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const {\n    active,\n    error,\n    activate\n  } = useWeb3React();\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleConnect = () => {\n        console.log(\"Handling 'connect' event\");\n        activate(injected);\n      };\n\n      const handleChainChanged = chainId => {\n        console.log(\"Handling 'chainChanged' event with payload\", chainId);\n        activate(injected);\n      };\n\n      const handleAccountsChanged = accounts => {\n        console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n\n        if (accounts.length > 0) {\n          activate(injected);\n        }\n      };\n\n      ethereum.on('connect', handleConnect);\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged); // cleanup function\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('connect', handleConnect);\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n  }, [active, error, suppress, activate]);\n}\n\n_s2(useInactiveListener, \"tg+LUTCYzAVRTYzC32Q8yta1BMA=\", false, function () {\n  return [useWeb3React];\n});","map":{"version":3,"sources":["/Users/akshaysawant/Downloads/Test/frontend/src/utils/hooks.ts"],"names":["useWeb3React","useCallback","useEffect","useState","injected","useEagerConnect","activate","active","tried","setTried","tryActivate","_tryActivate","isAuthorized","undefined","error","window","alert","message","useInactiveListener","suppress","ethereum","on","handleConnect","console","log","handleChainChanged","chainId","handleAccountsChanged","accounts","length","removeListener"],"mappings":";;;AAAA,SAASA,YAAT,QAA6B,kBAA7B;AACA,SAASC,WAAT,EAAsBC,SAAtB,EAAiCC,QAAjC,QAAiD,OAAjD;AACA,SAASC,QAAT,QAAyB,cAAzB;AAGA,OAAO,SAASC,eAAT,GAAoC;AAAA;;AACzC,QAAM;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,MAAuBP,YAAY,EAAzC;AAEA,QAAM,CAACQ,KAAD,EAAQC,QAAR,IAAoBN,QAAQ,CAAC,KAAD,CAAlC,CAHyC,CAKzC;AACA;;AACA,QAAMO,WAAW,GAAGT,WAAW,CAAC,MAAY;AAC1C,mBAAeU,YAAf,GAA8B;AAC5B,YAAMC,YAAY,GAAG,MAAMR,QAAQ,CAACQ,YAAT,EAA3B;;AAEA,UAAIA,YAAJ,EAAkB;AAChB,YAAI;AACF,gBAAMN,QAAQ,CAACF,QAAD,EAAWS,SAAX,EAAsB,IAAtB,CAAd;AACD,SAFD,CAEE,OAAOC,KAAP,EAAmB;AACnBC,UAAAA,MAAM,CAACC,KAAP,CACE,YAAYF,KAAK,IAAIA,KAAK,CAACG,OAAf,GAA0B,OAAMH,KAAK,CAACG,OAAQ,EAA9C,GAAkD,EAA9D,CADF;AAGD;AACF;;AAEDR,MAAAA,QAAQ,CAAC,IAAD,CAAR;AACD;;AAEDE,IAAAA,YAAY;AACb,GAlB8B,EAkB5B,CAACL,QAAD,CAlB4B,CAA/B;AAoBAJ,EAAAA,SAAS,CAAC,MAAY;AACpBQ,IAAAA,WAAW;AACZ,GAFQ,EAEN,CAACA,WAAD,CAFM,CAAT,CA3ByC,CA+BzC;;AACAR,EAAAA,SAAS,CAAC,MAAY;AACpB,QAAI,CAACM,KAAD,IAAUD,MAAd,EAAsB;AACpBE,MAAAA,QAAQ,CAAC,IAAD,CAAR;AACD;AACF,GAJQ,EAIN,CAACD,KAAD,EAAQD,MAAR,CAJM,CAAT;AAMA,SAAOC,KAAP;AACD;;GAvCeH,e;UACeL,Y;;;AAwC/B,OAAO,SAASkB,mBAAT,GAA8D;AAAA;;AAAA,MAAjCC,QAAiC,uEAAb,KAAa;AACnE,QAAM;AAAEZ,IAAAA,MAAF;AAAUO,IAAAA,KAAV;AAAiBR,IAAAA;AAAjB,MAA8BN,YAAY,EAAhD;AAEAE,EAAAA,SAAS,CAAC,MAAgC;AACxC,UAAM;AAAEkB,MAAAA;AAAF,QAAeL,MAArB;;AAEA,QAAIK,QAAQ,IAAIA,QAAQ,CAACC,EAArB,IAA2B,CAACd,MAA5B,IAAsC,CAACO,KAAvC,IAAgD,CAACK,QAArD,EAA+D;AAC7D,YAAMG,aAAa,GAAG,MAAY;AAChCC,QAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AACAlB,QAAAA,QAAQ,CAACF,QAAD,CAAR;AACD,OAHD;;AAKA,YAAMqB,kBAAkB,GAAIC,OAAD,IAAoC;AAC7DH,QAAAA,OAAO,CAACC,GAAR,CAAY,4CAAZ,EAA0DE,OAA1D;AACApB,QAAAA,QAAQ,CAACF,QAAD,CAAR;AACD,OAHD;;AAKA,YAAMuB,qBAAqB,GAAIC,QAAD,IAA8B;AAC1DL,QAAAA,OAAO,CAACC,GAAR,CAAY,+CAAZ,EAA6DI,QAA7D;;AACA,YAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAtB,EAAyB;AACvBvB,UAAAA,QAAQ,CAACF,QAAD,CAAR;AACD;AACF,OALD;;AAOAgB,MAAAA,QAAQ,CAACC,EAAT,CAAY,SAAZ,EAAuBC,aAAvB;AACAF,MAAAA,QAAQ,CAACC,EAAT,CAAY,cAAZ,EAA4BI,kBAA5B;AACAL,MAAAA,QAAQ,CAACC,EAAT,CAAY,iBAAZ,EAA+BM,qBAA/B,EApB6D,CAsB7D;;AACA,aAAO,MAAY;AACjB,YAAIP,QAAQ,CAACU,cAAb,EAA6B;AAC3BV,UAAAA,QAAQ,CAACU,cAAT,CAAwB,SAAxB,EAAmCR,aAAnC;AACAF,UAAAA,QAAQ,CAACU,cAAT,CAAwB,cAAxB,EAAwCL,kBAAxC;AACAL,UAAAA,QAAQ,CAACU,cAAT,CAAwB,iBAAxB,EAA2CH,qBAA3C;AACD;AACF,OAND;AAOD;AACF,GAlCQ,EAkCN,CAACpB,MAAD,EAASO,KAAT,EAAgBK,QAAhB,EAA0Bb,QAA1B,CAlCM,CAAT;AAmCD;;IAtCeY,mB;UACsBlB,Y","sourcesContent":["import { useWeb3React } from '@web3-react/core';\nimport { useCallback, useEffect, useState } from 'react';\nimport { injected } from './connectors';\nimport { Provider } from './provider';\n\nexport function useEagerConnect(): boolean {\n  const { activate, active } = useWeb3React<Provider>();\n\n  const [tried, setTried] = useState(false);\n\n  // use useCallback() and useEffect() hooks together so that tryActivate() will only\n  // be called once when attempting eager connection\n  const tryActivate = useCallback((): void => {\n    async function _tryActivate() {\n      const isAuthorized = await injected.isAuthorized();\n\n      if (isAuthorized) {\n        try {\n          await activate(injected, undefined, true);\n        } catch (error: any) {\n          window.alert(\n            'Error!' + (error && error.message ? `\\n\\n${error.message}` : '')\n          );\n        }\n      }\n\n      setTried(true);\n    }\n\n    _tryActivate();\n  }, [activate]);\n\n  useEffect((): void => {\n    tryActivate();\n  }, [tryActivate]);\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect((): void => {\n    if (!tried && active) {\n      setTried(true);\n    }\n  }, [tried, active]);\n\n  return tried;\n}\n\nexport function useInactiveListener(suppress: boolean = false): void {\n  const { active, error, activate } = useWeb3React<Provider>();\n\n  useEffect((): (() => void) | undefined => {\n    const { ethereum } = window as any;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleConnect = (): void => {\n        console.log(\"Handling 'connect' event\");\n        activate(injected);\n      };\n\n      const handleChainChanged = (chainId: string | number): void => {\n        console.log(\"Handling 'chainChanged' event with payload\", chainId);\n        activate(injected);\n      };\n\n      const handleAccountsChanged = (accounts: string[]): void => {\n        console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n        if (accounts.length > 0) {\n          activate(injected);\n        }\n      };\n\n      ethereum.on('connect', handleConnect);\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n\n      // cleanup function\n      return (): void => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('connect', handleConnect);\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n  }, [active, error, suppress, activate]);\n}\n"]},"metadata":{},"sourceType":"module"}